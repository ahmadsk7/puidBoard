/**
 * YouTube Cookie Fetcher
 *
 * Fetches fresh YouTube cookies from a remote API to bypass datacenter IP blocking.
 * Based on the yt-cookies Python library: https://pypi.org/project/yt-cookies/
 *
 * The remote API (http://185.158.132.66:1234/golden-cookies/ytc) provides
 * fresh cookies that are automatically rotated server-side.
 */

import { writeFile, unlink } from 'fs/promises';
import { existsSync } from 'fs';
import { resolve } from 'path';

const COOKIE_API_URL = 'http://185.158.132.66:1234/golden-cookies/ytc';
const COOKIE_FILE_PATH = resolve(process.cwd(), '.storage/youtube-cookies.txt');
const COOKIE_REFRESH_INTERVAL = 6 * 60 * 60 * 1000; // 6 hours

let lastCookieRefresh = 0;
let cookieFetchPromise: Promise<string | null> | null = null;

/**
 * Convert cookie object to Netscape format
 */
function cookieToNetscape(cookie: any): string {
  // Netscape format: domain, flag, path, secure, expiration, name, value
  const domain = cookie.domain || '.youtube.com';
  const flag = domain.startsWith('.') ? 'TRUE' : 'FALSE';
  const path = cookie.path || '/';
  const secure = cookie.secure ? 'TRUE' : 'FALSE';
  const expiration = cookie.expirationDate || Math.floor(Date.now() / 1000) + (365 * 24 * 60 * 60);
  const name = cookie.name;
  const value = cookie.value;

  return `${domain}\t${flag}\t${path}\t${secure}\t${expiration}\t${name}\t${value}`;
}

/**
 * Fetch fresh YouTube cookies from the remote API
 */
async function fetchCookiesFromAPI(): Promise<string> {
  console.log(`[YouTube Cookies] Fetching fresh cookies from API...`);

  try {
    const response = await fetch(COOKIE_API_URL, {
      method: 'GET',
      headers: {
        'User-Agent': 'puidboard-realtime/1.0'
      },
      signal: AbortSignal.timeout(3000) // 3 second timeout (fail fast if API is down)
    });

    if (!response.ok) {
      throw new Error(`Cookie API returned ${response.status}`);
    }

    const contentType = response.headers.get('content-type');

    // Check if response is JSON (cookie objects) or plain text (already formatted)
    if (contentType?.includes('application/json')) {
      const cookies = await response.json() as any[];

      // Convert to Netscape format
      const netscapeCookies = [
        '# Netscape HTTP Cookie File',
        '# This file is generated by yt-cookies API',
        '# Edit at your own risk.',
        ''
      ];

      for (const cookie of cookies) {
        netscapeCookies.push(cookieToNetscape(cookie));
      }

      return netscapeCookies.join('\n');
    } else {
      // Assume it's already in Netscape format
      const text = await response.text();

      // Verify it starts with the required header
      if (!text.includes('# Netscape HTTP Cookie File') && !text.includes('# HTTP Cookie File')) {
        // Add the header if missing
        return `# Netscape HTTP Cookie File\n${text}`;
      }

      return text;
    }
  } catch (error) {
    console.error('[YouTube Cookies] Failed to fetch cookies from API:', error);
    throw new Error(`Failed to fetch YouTube cookies: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Get the path to a valid YouTube cookies file.
 * Fetches fresh cookies from API if needed and writes to disk.
 *
 * @returns Path to cookies file, or null if cookies unavailable
 */
export async function getYouTubeCookiesPath(): Promise<string | null> {
  const now = Date.now();
  const needsRefresh = (now - lastCookieRefresh) > COOKIE_REFRESH_INTERVAL;

  // Check if we have a static cookie file from environment variable
  const staticCookiesPath = process.env.YOUTUBE_COOKIES_PATH;
  if (staticCookiesPath && existsSync(staticCookiesPath)) {
    console.log(`[YouTube Cookies] Using static cookies from: ${staticCookiesPath}`);
    return staticCookiesPath;
  }

  // If cookies are recent enough and file exists, use cached version
  if (!needsRefresh && existsSync(COOKIE_FILE_PATH)) {
    console.log(`[YouTube Cookies] Using cached cookies (${Math.floor((now - lastCookieRefresh) / 1000 / 60)}m old)`);
    return COOKIE_FILE_PATH;
  }

  // Prevent multiple simultaneous fetches
  if (cookieFetchPromise) {
    console.log('[YouTube Cookies] Cookie fetch already in progress, waiting...');
    await cookieFetchPromise;
    return existsSync(COOKIE_FILE_PATH) ? COOKIE_FILE_PATH : null;
  }

  // Fetch new cookies
  const fetchPromise: Promise<string | null> = (async () => {
    try {
      const cookieContent = await fetchCookiesFromAPI();
      await writeFile(COOKIE_FILE_PATH, cookieContent, 'utf8');
      lastCookieRefresh = Date.now();
      console.log(`[YouTube Cookies] âœ“ Fresh cookies written to ${COOKIE_FILE_PATH}`);
      return COOKIE_FILE_PATH;
    } catch (error) {
      console.error('[YouTube Cookies] Failed to refresh cookies:', error);

      // If we have an old cookie file, use it as fallback
      if (existsSync(COOKIE_FILE_PATH)) {
        console.warn('[YouTube Cookies] Using stale cookies as fallback');
        return COOKIE_FILE_PATH;
      }

      return null;
    } finally {
      cookieFetchPromise = null;
    }
  })();

  cookieFetchPromise = fetchPromise;

  return await cookieFetchPromise;
}

/**
 * Clean up cookie file (call on server shutdown)
 */
export async function cleanupCookies(): Promise<void> {
  try {
    if (existsSync(COOKIE_FILE_PATH)) {
      await unlink(COOKIE_FILE_PATH);
      console.log('[YouTube Cookies] Cookie file cleaned up');
    }
  } catch (error) {
    console.error('[YouTube Cookies] Failed to cleanup cookies:', error);
  }
}
